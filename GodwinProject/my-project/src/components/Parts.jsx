import React from 'react'
import PartForm from './PartsForm'
import PartList from './PartsList'
import API from '../PartAPI'
import PropTypes from 'prop-types'

function ErrorMessage ({ message }) {
  return <div className='errorMessage'>{message}</div>
}

ErrorMessage.propTypes = {
  message: PropTypes.string.isRequired
}

export default function Part () {
  const [partList, setPartList] = React.useState([])
  const [loadingMessage, setLoadingMessage] = React.useState('Loading...')
  const [errorMessage, setErrorMessage] = React.useState(null)

  const [formMode, setFormMode] = React.useState('new')

  const emptyPart = { sku: '', descr: '', retail: '' }
  const [currentPart, setCurrentPart] = React.useState(emptyPart)

  // Note:  The {} around API.fetchParts are important so that the block
  // passed to useEffect returns undefined (instead of the promise generated by fetch).
  React.useEffect(() => {
    API.fetchParts().then(data => {
      setPartList(data)
      setLoadingMessage(null)
    }).catch((message) => {
      setLoadingMessage('Unable to load parts because ' + message)
    })
  }, [])

  const updatePart = (field, value) => {
    const newPart = { ...currentPart }
    newPart[field] = value
    setCurrentPart(newPart)
  }

  const formSubmitted = () => {
    setErrorMessage(null)
    if (formMode === 'new') {
      API.postNewPart(currentPart).then(data => {
        console.log('Received data')
        console.log(data)
        if (data.id) {
          currentPart.id = data.id
          setPartList([...partList, currentPart])
        } else {
          console.log("New part wasn't created.")
        }
      }).catch(message => setErrorMessage(`Failed to create new part: ${message}`))
    } else {
      API.updatePart(currentPart).then(() => {
        const newPartList = [...partList]
        const partIndex = partList.findIndex((part) => part.id === currentPart.id)

        newPartList[partIndex] = currentPart
        setPartList(newPartList)
      }).catch(message => setErrorMessage(`Failed to update part: ${message}`))
    }
  }

  const editClicked = (part) => {
    setErrorMessage(null)
    setFormMode('update')
    setCurrentPart(part)
  }

  const cancelClicked = () => {
    setErrorMessage(null)
    setFormMode('new')
    setCurrentPart(emptyPart)
  }

  const deleteClicked = (id) => {
    API.deletePart(id).then(() => {
      setPartList(partList.filter((item) => item.id !== id))
      cancelClicked()
    }).catch(message => setErrorMessage(`Failed to delete part: ${message}`))
  }

  const errorBlock = errorMessage ? <ErrorMessage message={errorMessage} /> : null

  return (
    <div className="part">
      <h1>Part Information</h1>
      {errorBlock}
      <PartForm formMode={formMode} part={currentPart} updatePart={updatePart}
        submitCallback={formSubmitted} cancelCallback={cancelClicked} />
      <div />
      {loadingMessage
        ? <p>{loadingMessage}</p>
        : <PartList parts={partList} onEditClicked={editClicked} onDeleteClicked={deleteClicked} />
      }
    </div>
  )
}
